[{"year":"2022","title":"ddd","path":"docs/2022/DDD.md","tags":[],"time":"2022-10-08T14:48:05.852Z","instro":"<h1>实现领域驱动设计</h1>\n<h2>目录概要</h2>\n<ol>\n<li>DDD</li>\n<li>领域、子域、限界上下文</li>\n</ol>\n"},{"year":"2022","title":"ffmpeg","path":"docs/2022/FFmpeg.md","tags":[],"time":"2023-02-18T17:07:16.432Z","instro":"<h1>FFmpeg入门详解</h1>\n<h2>发展方向</h2>\n<ol>\n<li>技术方向<ol>\n<li>C++</li>\n</ol>\n</li>\n</ol>\n"},{"year":"2022","title":"guide","path":"docs/2022/guide.md","tags":[],"time":"2022-10-07T15:47:41.000Z","instro":"<h1>资料</h1>\n<h2>新增内容</h2>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> CICD</li>\n<li><input disabled=\"\" type=\"checkbox\"> Go语言学习和资料整理</li>\n</ul>\n"},{"year":"2022","title":"LearnAndroid","path":"docs/2022/LearnAndroid.md","tags":[],"time":"2022-10-07T16:06:57.118Z","instro":"<h1>深入理解Android</h1>\n<h2>资料推荐</h2>\n<ul>\n<li><a href=\"https://developer.android.com/guide/platform?hl=zh-cn\">Android官方文档</a></li>\n</ul>\n<h2>卷 一</h2>\n"},{"year":"2022","title":"LearnC","path":"docs/2022/LearnC.md","tags":[],"time":"2022-10-08T04:53:03.628Z","instro":"<h1>GuideToC</h1>\n<h2>简单介绍</h2>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 算法</li>\n<li><input disabled=\"\" type=\"checkbox\"> 计算机网络</li>\n</ul>\n"},{"year":"2022","title":"LearnGo","path":"docs/2022/LearnGo.md","tags":[],"time":"2022-10-07T15:47:41.148Z","instro":"<p>[TOC]</p>\n<h1>目录</h1>\n<h2>1. 基础部分(1~5)</h2>\n<ol>\n<li>基本结构：读写文件、文本格式化、创建图像、网络客户端、服务器通讯。</li>\n</ol>\n"},{"year":"2022","title":"NodeMicroArchitecture","path":"docs/2022/NodeMicroArchitecture.md","tags":[],"time":"2022-10-08T06:11:08.306Z","instro":"<h1>使用</h1>\n<ul>\n<li><code>kaust_DB</code>: 数据库</li>\n<li><code>kaust_cms_front</code>: 前端页面</li>\n<li><code>kaust_backend</code>: 后端服务</li>\n</ul>\n"},{"year":"2022","title":"NodeQA","path":"docs/2022/NodeQA.md","tags":[],"time":"2022-12-07T07:31:58.592Z","instro":"<h1>常见面试题</h1>\n<h2>1. Node并发处理</h2>\n<p>在面试过程中，忽然遇到一些问题，还算蛮有趣，因此写下来记录。\n以下为题目描述:</p>\n"},{"year":"2022","title":"PGSQL","path":"docs/2022/PGSQL.md","tags":[],"time":"2022-10-24T04:12:48.369Z","instro":"<h1>PGSQL修炼之道</h1>\n<h2>本书内容</h2>\n<ol>\n<li>提前准备</li>\n<li>基础知识</li>\n</ol>\n"},{"year":"2022","title":"SSL","path":"docs/2022/SSL.md","tags":[],"time":"2022-10-07T15:50:00.019Z","instro":"<h1>生成SSL证书</h1>\n<p>当我们自己颁布证书时，常用以下<code>shell</code>生成SSL证书：</p>\n<pre><code class=\"language-shell\">#!/bin/bash\n</code></pre>\n"},{"year":"2023","title":"instro","path":"docs/instro.md","tags":[],"time":"2023-06-04T17:55:11.798Z","instro":"<h1>Test Doc</h1>\n<ol>\n<li>It&#39;s a doc file.</li>\n<li><strong>111</strong></li>\n<li>121</li>\n</ol>\n"},{"year":"2023","title":"第一篇文章","path":"docs/2023/06/start.md","tags":[{"key":"php","name":"php","color":"#777","href":"/tags/php"}],"time":"2023-06-05T06:41:55.631Z","instro":"<h1>Start</h1>\n<p>第一篇文章</p>\n"},{"year":"2023","title":"第二篇文章","path":"docs/2023/06/second.md","tags":[],"time":"2023-06-05T11:58:13.190Z","instro":"<h1>Second Markdown File</h1>\n<p>It&#39;s a test for loading markdown files.</p>\n"},{"year":"2023","title":"第二篇文章","path":"docs/2023/06/second.md","tags":[],"time":"2023-06-05T11:58:13.190Z","instro":"<h1>Second Markdown File</h1>\n<p>It&#39;s a test for loading markdown files.</p>\n"},{"year":"2023","title":"技术选型","path":"docs/2023/06/blog.md","tags":[{"key":"front","name":"前端","color":"#888","href":"/tags/front"},{"key":"summary","name":"总结","color":"#4d4d4d","href":"/tags/summary"}],"time":"2023-06-11T18:15:27.420Z","instro":"<h1>Blog的个人感受</h1>\n<p>曾经觉得前端有很多的发展和未来，但是目前来看，我对前端的未来有些略微失望。不单单是目前的市场和场景的局限，另一方面是我对前端的理解和认知。</p>\n<h2>1. 导言</h2>\n<p>前端的发展，从最初的页面渲染，到后来的交互，再到现在的框架，前端的发展是越来越快，越来越复杂，越来越庞大。但是，我觉得前端的发展，是有些失去了方向，有些失去了自己的本质。</p>\n"},{"title":"前端的思考","path":"docs/2023/06/frontRecommand.md","tags":[{"key":"front","name":"前端","color":"#888","href":"/tags/front"},{"key":"summary","name":"总结","color":"#4d4d4d","href":"/tags/summary"}],"time":"2023-06-18T10:43:41.439Z","instro":"<h1>前端的思考- 终章</h1>\n<p>随着时间的发展和对业务的理解和程序的理解，越发觉得前端的天花板其实很低，本身是不具备任何技术门槛。即便是最为天花板的编辑器，其本身也是存在了不少的问题。\n还是那句话: 先学会用，再去做。不要把自己的时间浪费在一些不必要的事情上。</p>\n<h2>前端编辑器</h2>\n"},{"title":"如何搭建HTTP服务器调用DLL库","path":"docs/2023/06/node_dll.md","tags":[{"key":"node","name":"node","color":"#4d4d4d","href":"/tags/node"},{"key":"dll","name":"DLL","color":"#4d4d4d","href":"/tags/dll"}],"time":"2023-06-24T17:45:35.495Z","instro":"<h1>如何搭建HTTP服务器调用DLL库</h1>\n<p>之前在帮朋友救急时，忽然想到了这个方法，就是通过HTTP服务器调用DLL库。在某些情况下，我们可能需要远程调用本地的 DLL 库。为了实现这个目标，我们可以搭建一个 HTTP 服务器，通过发送 HTTP 请求来调用 DLL 库的函数。这种方法可以让我们在不将 DLL 库放到远程机器上的情况下，实现对 DLL 函数的远程调用。\n环境：MacOS + Node 18.0.0\n目的：酒店的房卡系统，通过HTTP服务器调用DLL库，实现对房卡的读取、写入、删除等操作。</p>\n"},{"title":"编译原理的思考的扩展","path":"docs/2023/06/compile.md","tags":[{"key":"compile","name":"compile","color":"#4d4d4d","href":"/tags/compile"}],"time":"2023-06-25T16:36:27.833Z","instro":"<h1>编译原理的思考的扩展</h1>\n<p>最近在写<code>AST</code>的插件。忽然发现自己对<code>AST</code>,<code>CST</code>的区别不是很清楚。\nAST（Abstract Syntax Tree）和 CST（Concrete Syntax Tree）是在编程语言处理中常见的两种树形结构，用于表示源代码的语法结构。它们在结构和应用上有一些区别。</p>\n<ol>\n<li>CST（Concrete Syntax Tree）：</li>\n</ol>\n"},{"title":"未来的思考","path":"docs/2023/07/future.md","tags":[{"key":"future","name":"future note","color":"#8501cc","href":"/tags/future"}],"time":"2023-07-12T14:51:30.253Z","instro":"<h1>关于未来的思考</h1>\n<p>在经历了几次惨痛的教训后，我对自己的能力和自身的问题有了深刻的印象。文章是逻辑、思考的沉淀和凝缩。因此学习和写作总结，是必不可少的过程。\n我的问题在于缺乏经验、学习速度慢。一是在做许多东西的时候，不够“熟手”，二则是在处理事情的过程中，学习和使用新东西的速度不够快。换句话说，现在接触的全部是新事物，然而我在直接上手和使用的过程中，始终是存在着不够熟练、速度比较慢的现象——归结到本质，我个人觉得其实是我不够“热爱”。我的精力非常分散。\n这非常致命。</p>\n"},{"title":"zig 的错误处理函数","path":"docs/2023/07/zigHandleError.md","tags":[{"key":"zig","name":"zig note","color":"#8501cc","href":"/tags/zig"},{"key":"Handle Error","name":"error","color":"#3d3d3d","href":"/tags/Handle Error"}],"time":"2023-07-26T13:13:13.852Z","instro":"<h1>Zig 编译器-Bog 捕获错误的优势写法</h1>\n<p>在阅读一个开源项目 Bog 时,恰好看到编写的虚拟机,在处理运行中的错误时所使用的写法。为止新奇，但确实要方便一些，只是学习成本比较高。</p>\n<pre><code class=\"language-zig\">pub fn run(vm: *Vm, f: *Frame) (Error || error{Suspended})!*Value {\n</code></pre>\n"},{"title":"[Rust]-如何设计 Mail Send 的基础库","path":"docs/2023/07/rust_HowtoDesignMailSend.md","tags":[{"key":"rust","name":"rust note","color":"#8501cc","href":"/tags/rust"},{"key":"smtp","name":"smtp","color":"#3d3d3d","href":"/tags/smtp"}],"time":"2023-07-29T15:32:26.205Z","instro":"<h1>[Rust]-如何设计 Mail Send 的基础库</h1>\n<p>最近在 Rust 的学习过程中，看到一个蛮有意思的项目: <a href=\"https://github.com/stalwartlabs/mail-send\">mail-send</a>。\n该项目是从零手写的一个邮件发送库，支持 SMTP 协议，支持 DKIM 签名，支持 TLS 加密，支持多种认证方式，支持异步等等。\n具体介绍和使用不再赘述，可以去看看官方的资料: <a href=\"https://github.com/stalwartlabs/mail-send\">ReadMe</a>。</p>\n"},{"title":"[Rust]-WAV 音频命令行工具`zrtstr`解析","path":"docs/2023/07/rust_wav_process.md","tags":[{"key":"rust","name":"rust note","color":"#8501cc","href":"/tags/rust"},{"key":"wav","name":"wav","color":"#3d3d3d","href":"/tags/wav"}],"time":"2023-07-31T07:40:47.059Z","instro":"<h1>[Rust]-WAV 音频命令行工具<code>zrtstr</code>解析</h1>\n<p>Awesome-Rust 常年身居第一，是 Rust 早期版本的一个工具。它的主要功能是：检查立体声 WAV 文件是否具有相同的通道（假立体声）并将其转换为单声道。\n项目连接: <a href=\"https://github.com/indiscipline/zrtstr\">zrtstr</a></p>\n<h2>梗概</h2>\n"},{"title":"前端富文本编辑器关于 OP 与 CRDT 的总结","path":"docs/2023/07/richText_OP_CRDT.md","tags":[{"key":"OP","name":"OP","color":"#8501cc","href":"/tags/OP"},{"key":"CRDT","name":"CRDT","color":"#3d3d3d","href":"/tags/CRDT"}],"time":"2023-07-22T18:43:01.331Z","instro":"<h1>前端富文本编辑器关于 OP 与 CRDT 的总结</h1>\n<h1>绪论</h1>\n<p>国内的富文本资料很少，而且研究这方面的人也很少。或许是我研究和探索不够，一叶障目，对外界主流缺乏认知。在研究 Appflowy、分布式系统后，暂将富文本的协同核心点列出来对比。</p>\n<h1>OP 与 CRDT</h1>\n"},{"title":"【Web3】Remix(Ethereum IDE) 插件之 solidity-uml-gen，动手搓基建","path":"docs/2023/08/remix_plugin_explain.md","tags":[{"key":"remix","name":"Remix note","color":"#8501cc","href":"/tags/remix"},{"key":"solidity","name":"Solidity","color":"#3d3d3d","href":"/tags/solidity"}],"time":"2023-07-31T17:13:42.106Z","instro":"<h1>【Web3】Remix(Ethereum IDE) 插件之 solidity-uml-gen，</h1>\n<blockquote>\n<p>前阵子在啃<code>Remix</code>的源代码，在给<code>official-remix</code>贡献代码。给自己留下一些记录，方便今后回来查找和阅读，也是另一种整理。\n官方简介:\nRemix Ethereum IDE 是一个基于 Web 的集成开发环境（IDE），专门用于智能合约的开发、调试和部署。它是以太坊区块链上智能合约的一个流行开发工具，由以太坊社区开发和维护。Remix 提供了一个用户友好的界面，允许开发者在浏览器中编写、测试和优化智能合约代码。</p>\n</blockquote>\n"},{"title":"【中文】高并发：从一次 Agoda 系统设计面试中的收获","path":"docs/2023/08/agoda_interview_full_zh.md","tags":[],"time":"2023-08-10T12:16:43.644Z","instro":"<h1>高并发：从一次 Agoda 系统设计面试中的收获</h1>\n<p>分享一个我在应聘 Senior Full Stack Engineer 职位时的面试经历。由于我的英语口语有限，这次面试对我来说是一次相当大的挑战。\n当我走进面试室的时候，我就意识到这是一次具有挑战性的机会。这是第二轮面试。\n在我参与 Agoda 高级全栈职位的面试过程中，我充分意识到前方的道路将是严峻而复杂的。这个职位对前端和后端技术的深度和广度强调非常重要，意味着面试过程自然会在复杂性和设计期望方面逐渐提升。</p>\n"},{"title":"【En】High Concurrency: What I Learned from a System Design Interview with Agoda","path":"docs/2023/08/agoda_interview_full_en.md","tags":[],"time":"2023-08-10T10:44:07.412Z","instro":"<h1>High Concurrency: What I Learned from a System Design Interview with Agoda</h1>\n<p>Share an interview with Senior Full Stack Engineer. For my limited oral english, it&#39;s a tough time for my interviewer.\nI knew I was in for a challenge when I stepped into the room of the interview. It&#39;s round 2.\nAs I embarked on the journey of interviewing for the Senior Full Stack position, I was well aware that the path ahead would be demanding and intricate. The role&#39;s emphasis on depth and breadth across both front-end and back-end technologies meant that the interview process would naturally elevate complexity and design expectations.</p>\n"},{"title":"【JP】高並行性: アゴダのシステムデザイン面接から学んだこと","path":"docs/2023/08/agoda_interview_full_jp.md","tags":[],"time":"2023-08-10T12:26:32.705Z","instro":"<h1>高並行性: アゴダのシステムデザイン面接から学んだこと</h1>\n<p>シニアフルスタックエンジニアとしての面接を共有します。私の英語が十分でなく、面接官にとっては厳しい状況でした。\n面接の部屋に足を踏み入れたとき、私はチャレンジに直面していることを理解しました。これは 2 回目の面接です。\nAgoda でシニアフルスタックの職位に応募する旅に乗り出す中で、前端とバックエンドの両方の技術にわたる深さと広がりに重点を置いたこの役割は、面接プロセスが自然に複雑さとデザインの期待値を高めることを意味していることをよく理解していました。</p>\n"},{"title":"【Fr】Haute Concurrency : Ce que j'ai appris d'un entretien sur la conception de système avec Agoda","path":"docs/2023/08/agoda_interview_full_fr.md","tags":[],"time":"2023-08-10T12:41:42.771Z","instro":"<p><strong>Haute Concurrency : Ce que j&#39;ai appris d&#39;un entretien sur la conception de système avec Agoda</strong>\nPartage d&#39;un entretien en tant que Senior Full Stack Engineer. Pour ma maîtrise de l&#39;anglais, ce fut un moment difficile avec mon interlocuteur.\nJe savais que j&#39;allais être confronté à un défi lorsque j&#39;ai pénétré dans la salle d&#39;entretien. C&#39;était le deuxième tour.\nAlors que je me lançais dans le processus d&#39;entretien pour le poste de Senior Full Stack chez Agoda, je savais très bien que le chemin à parcourir serait exigeant et complexe. L&#39;accent mis sur la profondeur et l&#39;étendue des technologies front-end et back-end signifiait que le processus d&#39;entretien évoluerait naturellement en termes de complexité et d&#39;attentes en matière de conception.</p>\n"},{"title":"【中文】前端架构-现代API请求中的设计","path":"docs/2023/08/Architect_api_fetch_zh.md","tags":[],"time":"2023-08-15T04:08:12.591Z","instro":"<h1>前端架构-现代API请求中的设计</h1>\n<h2>引言</h2>\n<p>&quot;数据获取&quot;（Data Fetching）指的是从服务器或其他数据源获取数据以供在前端界面上显示和操作的过程。这个过程在现代Web应用中至关重要，因为大多数应用都需要与后端服务器进行通信，以获取数据并实现用户界面的更新。数据获取在前端架构中扮演了连接用户界面和后端数据的桥梁作用，使应用能够呈现实时、准确的信息。\n<strong>1. 为什么数据获取在前端架构中至关重要？</strong></p>\n"},{"title":"【En】Simple Introduction: Efficient Data Fetching in Frontend Applications","path":"docs/2023/08/Architect_api_fetch_en.md","tags":[],"time":"2023-08-15T04:40:59.600Z","instro":"<h1>Simple Introduction: Efficient Data Fetching in Frontend Applications</h1>\n<h2>Introduction</h2>\n<p><strong>Data fetching</strong> refers to the process of retrieving data from servers or other data sources for display and manipulation on the frontend interface. This process is crucial in modern web applications as most apps require communication with backend servers to obtain data and update user interfaces. Data fetching acts as a bridge between frontend architecture and backend data, enabling applications to present real-time, accurate information.\n<strong>1. Importance of Data Fetching in Frontend Architecture</strong></p>\n"},{"title":"【Jp】フロントエンドアーキテクチャ - 現代のAPIリクエストデザイン","path":"docs/2023/08/Architect_api_fetch_jp.md","tags":[],"time":"2023-08-15T05:11:06.418Z","instro":"<h1>フロントエンドアーキテクチャ - 現代のAPIリクエストデザイン</h1>\n<h2>序論</h2>\n<p>「データ取得」（Data Fetching）は、サーバーまたは他のデータソースからデータを取得し、フロントエンドインターフェースで表示および操作するプロセスを指します。このプロセスは、現代のWebアプリケーションにおいて非常に重要であり、ほとんどのアプリケーションはユーザーインターフェースとバックエンドサーバーとの間で通信し、データを取得してユーザーインターフェースを更新します。データ取得は、フロントエンドアーキテクチャでユーザーインターフェースとバックエンドデータを接続する橋渡しの役割を果たし、リアルタイムで正確な情報を提供することができるようにします。\n<strong>1. データ取得はなぜフロントエンドアーキテクチャで重要なのですか？</strong></p>\n"},{"title":"【Cn】【Go】Minio源码解析（一）——入口函数、位腐败算法、服务器入口点","path":"docs/2023/08/Minio_Source_Instro_zh.md","tags":[],"time":"2023-08-20T06:14:53.130Z","instro":"<h1>【Go】Minio源码解析（一）——入口函数、位腐败算法、服务器入口点</h1>\n<p>MinIO 是一个开源的对象存储服务器，旨在实现高性能、高可用性的分布式对象存储解决方案。它是一个兼容Amazon S3（Simple Storage Service）的服务器，可以用于构建私有云存储、公有云存储、备份、归档以及大规模数据存储等应用场景。MinIO 支持大规模数据存储、高速数据传输以及对象元数据的存储和检索。\nMinIO 主要的特点和用途包括：</p>\n<ol>\n<li><strong>分布式对象存储</strong>：MinIO 可以横向扩展，将数据分布到多个存储节点上，以提供高性能和可伸缩性。</li>\n</ol>\n"},{"title":"【En】[Go] MinIO Source Code Analysis (Part 1) - Entry Function, Bitrot Algorithm, Server Entry Points","path":"docs/2023/08/Minio_Source_Instro_en.md","tags":[],"time":"2023-08-20T07:03:36.205Z","instro":"<h1>[Go] MinIO Source Code Analysis (Part 1) - Entry Function, Bitrot Algorithm, Server Entry Points</h1>\n<p>MinIO is an open-source object storage server designed to deliver high-performance, high-availability distributed object storage solutions. It is a server compatible with Amazon S3 (Simple Storage Service) and can be used to build private cloud storage, public cloud storage, backup, archiving, and large-scale data storage applications. MinIO supports massive data storage, high-speed data transfer, and the storage and retrieval of object metadata.\nThe main features and use cases of MinIO include:</p>\n<ol>\n<li><strong>Distributed Object Storage</strong>: MinIO can scale horizontally, distributing data across multiple storage nodes to provide high performance and scalability.</li>\n</ol>\n"},{"title":"【Jp】【Go】Minioソースコード解析（1） - エントリポイント、ビット腐敗アルゴリズム、サーバーエントリーポイント","path":"docs/2023/08/Minio_Source_Instro_jp.md","tags":[],"time":"2023-08-20T08:58:05.697Z","instro":"<h1>【Go】Minioソースコード解析（1） - エントリポイント、ビット腐敗アルゴリズム、サーバーエントリーポイント</h1>\n<p>MinIOは、高性能で高可用性の分散オブジェクトストレージソリューションを実現するためのオープンソースオブジェクトストレージサーバーです。これはAmazon S3（Simple Storage Service）と互換性があり、プライベートクラウドストレージ、パブリッククラウドストレージ、バックアップ、アーカイブ、大規模データストレージなど、さまざまなアプリケーションシナリオに使用できます。MinIOは大規模データのストレージ、高速データ転送、オブジェクトメタデータのストレージと検索をサポートしています。\nMinIOの主な特徴と用途は次のとおりです：</p>\n<ol>\n<li><strong>分散オブジェクトストレージ</strong>：MinIOは水平にスケーリングでき、データを複数のストレージノードに分散して高性能とスケーラビリティを提供します。</li>\n</ol>\n"}]